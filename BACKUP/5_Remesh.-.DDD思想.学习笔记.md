# [Remesh / DDD思想 学习笔记](https://github.com/silver-blinder/GitBlog/issues/5)

## 背景：需要解决的问题是什么？

DDD 想要解决的问题，简单地说，就是需求模型不清晰的问题。

需求模型不清晰，本质原因很大程度在于 **自然语言歧义空间大（**不是所有人都对问题领域有足够的专业知识，也就是说，不是所有人的意见都一样重要）**。 而其带来的问题在于：**偶尔让软件产生巨大的资金损失，但常常让软件产生不必要的复杂度。

由此，DDD的思想起点是 开发团队应该更早介入讨论，补充必要的**交流上下文**（前提是应当以当前领域专家为核心推进整个领域建模过程）。

**领域模型与实际开发的关系：**构建的领域模型，必须要同步到代码里，代码也必须要反映领域模型；通过模型跟代码的双向同步，才能最终得到可靠的软件交付。

## DDD 是如何有助于提升代码质量？

### 首先，如何衡量代码质量 / 性能提升 ？

它们的关键因素都是，要先有一个量化指标，不能只靠感觉，只靠主观评估。正所谓，没有度量，就没有优化，下图为当前普遍所认为的评估标准：

![image.png](attachment:f82d9e8e-fd00-49fd-8a1b-eba8c5934dd2:image.png)

### 所以，当前普遍所认为的评估标准问题在哪里？

先举两个例子：

![image.png](attachment:af784909-a815-41b2-baf4-fb2643a27bb0:image.png)

例如上图关于一个数据结构类型定义的例子：

左侧（主流上偏向数据库为核心的定义方式）所产生的问题在于：

**尽管类型数量简洁（一般依靠注释来说明字段含义），但其将互斥的操作放到一起并存，关系从 Or 变成了 And ，从加法复杂度变成乘法复杂度。**

而DDD思想下的右侧定义模式：
尽管从两个类型，变成了 9 个类型，一行注释都没有，代码行数也比前面的版本多出一倍以上，并且还有很多重复字段，比如 name 和 email 在好几个类型里都出现了，但是它更加**忠诚地反映了领域知识**。比如，用户要么是登录用户，要么是未登录用户；这条规则对应的类型定义，就是 UserInfo 等于 LoginUserInfo 跟 GestUserInfo 两个类型的联合类型。同时，**用类型把非法状态，扼杀在编译期**，由类型系统提供约束能力（当用户未登录时，它命中的是 GestUserInfo，它压根没有 email 字段，所以我们的代码也不可能错判）。

同样的，在处理流程建模过程中也会出现类似的问题：

![image.png](attachment:ccb675e7-0567-4609-a8e7-e3fff1b73593:image.png)

在一般情况下很容易写出右侧的代码，定义一个 Post class，封装所有操作，遇到非法操作就抛出错误。

但用DDD思想来看，其中的问题在于：
**审核中的帖子不能修改，不是指调用 edit 方法就报错，而是压根没有 edit 方法。**前者的问题在于代码里的真命题（多出来的方法调用），是领域里的假命题，它们成了**非法操作(Illegal-Operations)** 所有调用方法的地方，**都需要做防御性判断，排除非法调用，否则可能导致程序抛错和出 Bug。（增加风险和改错成本）**

总而言之，当前主流评估标准下的数据管理/流程控制的问题是：**对于领域知识的认知水平不足所导致的代码上能调用的函数/方法（可访问的字段）的数量(terms size)，大于领域知识里的真命题的实际需求。**

而DDD思想下的核心在于 领域知识＋技术能力两者的不可分割，代码应当忠诚地反映领域知识，**在事前定义的时候就规避领域里的假命题，锁死非法操作。**

实际使用 DDD+ADT（代数数据类型）思想的核心技巧：多用 Sum type，少用 Product type，减少非法状态和非法操作的泄漏

## DDD框架的引入：解决无法表达的类型/方法定义问题

![image.png](attachment:9207389f-f271-438e-996f-f15ba44590f4:image.png)

在上面的例子中看：想要在类型上表达出大于或等于 18，需要用到 **Refinment types 或者 Dependent types 这两种高级的类型特性**。具体来说就是，用花括号去定义类型，但它表达的不是一个对象，而是一个类型表达式。在花括号内，竖杠左侧是类型定义，跟它对应的值，比如v。但ts目前不支持。

也就是说，在这种情况下，**当我们无法在类型上约束数据的读写，我们就得在运行时去约束**

从而，DDD框架中引入了**query/command层**：在数据消费者和数据储存之间，引入一个中间层：**Command Model 负责写入数据，Query Model 负责查询数据。没有直接暴露底层状态，而是暴露两组方法，query 部分负责查询，command 部分负责写入。**

由此，在上述的场景下，类型上无法约束的部分可以在 updateTraveler 这个 command 方法里，按照领域规则，验证年龄，遇到非法输入，就抛出错误。有了这一层，我们的底层数据就难以被写入非法状态。

**接下来的问题是**，在上述场景下，当遇到非法输入的时候，抛出运行时错误，这是一个一对一的关系，只有 command 的调用者能够 catch 到这个错误。那么，如果其它数据消费者，也关心某个事件，应该怎么做呢？

从而框架引入 Domain Event (领域事件)这个概念，CQRS（command，query） 是面向**数据模型**的，领域事件则面向**通讯模型**。它是一对多的关系，数据消费者可以订阅特定的领域事件，然后 Command Model 里可以发布领域事件。

进一步，框架还引入 **Domain Effect (领域副作用)**。

解决的场景是：有很多领域问题，是跟副作用相关的，或者不需要外部调用 command 去驱动的。比如：

- 2秒内多次发布指令以最后一次为准（防抖，Debounce）
- 2秒内不能多次响应指令（节流，Throttle）
- 红绿灯（倒计时，Count-down；自驱动，Self-Driven）
- 复杂动画交互（动画，Animation）
- 当 A 事件发生后，如果B 时间内C 事件不发生，则发送D 指令(时间相关的条件事件，Time-related conditional events)

Effect Model的引入是为了去对接定时器等副作用来源，否则我们的领域模型，甚至连简单的红绿灯都不能自洽地表达出来。

至此，完整的领域模型，包含三个要素：**数据模型、通讯模型和行为模型。其不只是一种数据结构，也包含通讯能力跟副作用行为。**

## Remesh的核心：把领域模型，放到了最核心的位置

**DDD框架/Remesh的核心是把领域模型，放到了最核心的位置，把数据库、UI 等IO 设备，隔离到最外部。内圈模块，不能依赖外圈模块，外圈模块才可以依赖内圈模块。强调领域逻辑的独立性和内聚，领域模型可以脱离数据库、脱离 UI，独立地运行和测试。**

举例来说，比如一个状态管理库，往往不会阻止你在 React 组件里编写异步请求代码，获取数据。但是，DDD 框架会阻止你。

因为，React 组件属于 UI 层，在依赖关系的最外圈；而异步数据请求，却是接近内圈的领域模型的一部分。所以，它应该写在领域模型里，在 React 组件只剩下调用接口的代码，可能就只剩下一行代码。

## 从层次的角度思考

协作层 
软件开发不仅仅是软件与编程，而是多种职能的协作，是协同设计（co-design）的过程。

架构层

就是代码写在哪里、由谁来写的问题。同一个领域知识和需求，不应有两份互不同步的代码实现。

实现层

尽可能反映业务领域里的需求和知识表达

例如：正确使用 ADT 表达领域知识的内在关系，利用 compiler 的 type-check能力，更早更全面地覆盖和保持代码里的领域知识。