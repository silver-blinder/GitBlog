# [服务端渲染完整过程梳理 + 关于水合的一个问题解决](https://github.com/silver-blinder/GitBlog/issues/3)

<h2>服务端渲染相关：</h2>
<pre><code class="language-jsx">用户访问 例如： /xvisa/product/detail?productid=12345
       ↓
服务器接收请求
       ↓
NFES 路由系统判断：这是 SSR 页面（isForceCsr flag判断）
       ↓
加载页面模板 (config/template/page.js)（如果有，相当于父类BasePage）
       ↓
模板动态导入页面 (productDetail/index.tsx)
       ↓
调用 BasePage.getInitialState(ctx：上下文对象（详见ps）)（框架决定，开启SSR则在服务端运行）
       ↓
在 getInitialState 中检查并调用对应子类的getTdk getStaticProps getInitialState
（取决于对应的子类有没有定义） 
(getTdk ：SEO中标题（Title）、描述（Description）、关键词（Keywords）三个元标签的统称；
 getStaticProps: 构建时执行(build)；一次性；静态数据的获取
 getInitialState：请求时执行（用户访问时）；实时数据；个性化内容 ）
(类似于nextjs中的getStaticProps &amp;&amp; getServerSideProps）
       ↓
获取 SEO 数据 { title, description, image } / initServerState / initState
       ↓
渲染 HTML 并注入 SEO 元标签（如果有，NFES里setTDK会自动在meta标签内）,发送完整的 HTML
给客户端（将状态序列化到 window.__INITIAL_STATE__ 或类似的全局变量中）
(双重渲染：
 第一次（服务端）：
 const html = ReactDOMServer.renderToString(&lt;ProductDetail /&gt;);
 return `
      &lt;html&gt;
        &lt;head&gt;
	        &lt;title&gt;日本个人旅游签证&lt;/title&gt;
				  &lt;meta name=&quot;description&quot; content=&quot;专业签证服务，快速办理日本个人旅游签证&quot; /&gt;
					&lt;meta property=&quot;og:title&quot; content=&quot;日本个人旅游签证&quot; /&gt;
				  &lt;meta property=&quot;og:description&quot; content=&quot;专业签证服务...&quot; /&gt;
					&lt;meta property=&quot;og:image&quot; content=&quot;&lt;https://pic.ctrip.com/japan.jpg&gt;&quot; /&gt;
				  &lt;meta property=&quot;og:type&quot; content=&quot;website&quot; /&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id=&quot;root&quot;&gt;${html}&lt;/div&gt;
          &lt;script&gt;
            window.__INITIAL_STATE__ = {...initServerState, ...initState}
          &lt;/script&gt;
          &lt;script src=&quot;/app.js&quot;&gt;&lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    `;
)
水合阶段第二次：ReactDOM.hydrateRoot(document.getElementById('root'),
 &lt;ProductDetail /&gt;);
       ↓
客户端水合：
(DOM比对和复用；事件监听器绑定；状态初始化
 &lt;!-- 服务端生成的HTML --&gt;
 &lt;div id=&quot;root&quot;&gt;
   &lt;h1&gt;欢迎来到网站&lt;/h1&gt;
   &lt;button&gt;0&lt;/button&gt;  &lt;!-- 静态，点击无效 --&gt;
 &lt;/div&gt;

 &lt;script&gt;
 // 水合过程开始
 const App = () =&gt; {
   const [count, setCount] = useState(0);
   return (
     &lt;div&gt;
       &lt;h1&gt;欢迎来到网站&lt;/h1&gt;
       &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{count}&lt;/button&gt;
     &lt;/div&gt;
   );
 };

 // React的水合
 ReactDOM.hydrateRoot(document.getElementById('root'), &lt;App /&gt;);

 // 内部过程：
 // 1. 检查h1标签：内容匹配 ✅ -&gt; 复用
 // 2. 检查button标签：内容匹配 ✅ -&gt; 复用 + 绑定onClick
 // 3. 初始化useState(0)
 // 4. 现在button可以响应点击了！🎉
 &lt;/script&gt;)
</code></pre>
<p>ps：</p>
<p>ctx 是<strong>Nfes 框架（Nextjs也是类似）在服务端渲染时自动创建并传递的上下文对象</strong></p>
<p>，它包含了：</p>
<ul>
<li><strong>HTTP 请求/响应对象</strong> (req/res)</li>
<li><strong>URL 参数</strong> (query)</li>
<li><strong>路由信息</strong> (pathname, params)</li>
<li><strong>其他请求相关信息</strong></li>
</ul>
<h2>记录一个水合相关的报错：</h2>
<p>起因：出现以下报错</p>
<pre><code>Warning: Did not expect server HTML to contain a &lt;div&gt; in &lt;div&gt;. Error Component 
Stack

hook.js:608 Warning: An error occurred during hydration. The server HTML was 
replaced with client content in &lt;div&gt;. 

hydration-dev.js:31 Uncaught Error: [NFES] Page Error due to Hydration Failed, 
Please fix hydration errors above.
</code></pre>
<p>通过参考文档：<a href="https://nextjs.org/docs/messages/react-hydration-error%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8A%E8%BF%B0%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93%E7%9A%84%E5%88%86%E6%9E%90%E5%8F%AF%E7%9F%A5%EF%BC%9A">https://nextjs.org/docs/messages/react-hydration-error，以及上述关于二次渲染的分析可知：</a></p>
<p>本质是 <strong>服务端渲染与客户端渲染的内容不一致。</strong></p>
<p>具体场景：</p>
<pre><code>// 环境判断
const isTds = () =&gt; {
  const isH5 = xEnv.getPlatform() === xEnv.PLATFORM_TYPE.H5
  // 先只判断h5
  if (!isH5) return false
  if (xUa.isInServer()) return false
  let host = window?.location?.host
  if (host) {
    return host.includes('bst')
  } else {
    return false
  }
}

const isInWechatMiniProgram = () =&gt; {
  if (xUa.isInServer()) return false
  if (xEnv.getPlatform() === xEnv.PLATFORM_TYPE.CRN) return false
  try {
    let userAgent = getUserAgent().toLowerCase()
    if (userAgent.indexOf('micromessenger') &gt; -1) {
      return (
        window.__wxjs_environment === 'miniprogram' ||
        /miniProgram/i.test(window.navigator.userAgent)
      )
    } else {
      return false
    }
  } catch (e) {
    return false
  }
}

const isInTdsMiniProgram = () =&gt; {
  if (xUa.isInServer()) return false
  return isInWechatMiniProgram() &amp;&amp; isTds()
}
</code></pre>
<pre><code>const ProductDetail = (props) =&gt; {
  console.log('isInTdsMini',isInTdsMiniProgram())
  return (
    &lt;XView &gt;
      &lt;Header /&gt;
      ....
    &lt;/Xview&gt;
  )
}
</code></pre>
<p>报错发生在ProductDetail页面上，根据文档，首先最有可能的是在组件内使用/调用了和window相关/客户端下的API，但检查了一下发现并没有；</p>
<p>然后一直觉得十分奇怪：对于isInTdsMiniProgram 的判断 在服务端内会被直接返回false；在客户端内isTds由于域名不是bst相关也会返回false，也就是说isInTdsMiniProgram在服务端和客户端下都会是false，怎么会出现水合不一致的情况呢？</p>
<p>然后就进入调试阶段，在两端内分别输出了一系列值（例如isInTdsMiniProgram、isTds、isH5等等等），经过尝试，我发现问题可能出在isTds这里，当我强制将这个值返回true的时候，水合不一致报错消失，返回false时，就会报错。</p>
<p>顺着这个思路，我发现isInTdsMiniProgram不一致反而不会报水合的错误，那就说明一定有别的判断也是在服务端/客户端不一致，负负得正的感觉。</p>
<p>最后在Header内找到了问题：</p>
<pre><code>const Header = (props: Props) =&gt; {
  if ((xUa.isMini() || xUa.isInMini()) &amp;&amp; !isInTdsMiniProgram()) return null
  ....
}
</code></pre>
<p><strong>情况1：isTds() 返回 false</strong></p>

环境 | xUa.isInMini() | isInTdsMiniProgram() | Header条件 | 渲染结果
-- | -- | -- | -- | --
服务端 | false | false | false && true → false | 正常渲染
客户端 | true | false | true && true → true | 返回 null


<p><strong>结果</strong>：水合一致</p>
<p>原因在于xUa.isInMini()这个方法在服务端内会返回false，客户端内才会返回true（ navigator方法判断ua）。</p>
<p>当然这只是调试阶段出现的问题，生产测试上会更改host（二编：最终改成了根据登陆态判断cookie），但通过这个例子更加深入理解了水合这一过程，也提醒我不要轻易想当然（想当然的认为isInTdsMiniProgram值就是应该一致）。</p>
<!-- notionvc: cd4cc2b4-d22b-41f2-a43e-c3e246416856 -->## 服务端渲染相关：

```jsx
用户访问 例如： /xvisa/product/detail?productid=12345
       ↓
服务器接收请求
       ↓
NFES 路由系统判断：这是 SSR 页面（isForceCsr flag判断）
       ↓
加载页面模板 (config/template/page.js)（如果有，相当于父类BasePage）
       ↓
模板动态导入页面 (productDetail/index.tsx)
       ↓
调用 BasePage.getInitialState(ctx：上下文对象（详见ps）)（框架决定，开启SSR则在服务端运行）
       ↓
在 getInitialState 中检查并调用对应子类的getTdk getStaticProps getInitialState
（取决于对应的子类有没有定义） 
(getTdk ：SEO中标题（Title）、描述（Description）、关键词（Keywords）三个元标签的统称；
 getStaticProps: 构建时执行(build)；一次性；静态数据的获取
 getInitialState：请求时执行（用户访问时）；实时数据；个性化内容 ）
(类似于nextjs中的getStaticProps && getServerSideProps）
       ↓
获取 SEO 数据 { title, description, image } / initServerState / initState
       ↓
渲染 HTML 并注入 SEO 元标签（如果有，NFES里setTDK会自动在meta标签内）,发送完整的 HTML
给客户端（将状态序列化到 window.__INITIAL_STATE__ 或类似的全局变量中）
(双重渲染：
 第一次（服务端）：
 const html = ReactDOMServer.renderToString(<ProductDetail />);
 return `
      <html>
        <head>
	        <title>日本个人旅游签证</title>
				  <meta name="description" content="专业签证服务，快速办理日本个人旅游签证" />
					<meta property="og:title" content="日本个人旅游签证" />
				  <meta property="og:description" content="专业签证服务..." />
					<meta property="og:image" content="https://pic.ctrip.com/japan.jpg" />
				  <meta property="og:type" content="website" />
        </head>
        <body>
          <div id="root">${html}</div>
          <script>
            window.__INITIAL_STATE__ = {...initServerState, ...initState}
          </script>
          <script src="/app.js"></script>
        </body>
      </html>
    `;
)
水合阶段第二次：ReactDOM.hydrateRoot(document.getElementById('root'),
 <ProductDetail />);
       ↓
客户端水合：
(DOM比对和复用；事件监听器绑定；状态初始化
 <!-- 服务端生成的HTML -->
 <div id="root">
   <h1>欢迎来到网站</h1>
   <button>0</button>  <!-- 静态，点击无效 -->
 </div>

 <script>
 // 水合过程开始
 const App = () => {
   const [count, setCount] = useState(0);
   return (
     <div>
       <h1>欢迎来到网站</h1>
       <button onClick={() => setCount(count + 1)}>{count}</button>
     </div>
   );
 };

 // React的水合
 ReactDOM.hydrateRoot(document.getElementById('root'), <App />);

 // 内部过程：
 // 1. 检查h1标签：内容匹配 ✅ -> 复用
 // 2. 检查button标签：内容匹配 ✅ -> 复用 + 绑定onClick
 // 3. 初始化useState(0)
 // 4. 现在button可以响应点击了！🎉
 </script>)
```

ps：

ctx 是**Nfes 框架（Nextjs也是类似）在服务端渲染时自动创建并传递的上下文对象**

，它包含了：

- **HTTP 请求/响应对象** (req/res)
- **URL 参数** (query)
- **路由信息** (pathname, params)
- **其他请求相关信息**

## 记录一个水合相关的报错：

起因：出现以下报错

```
Warning: Did not expect server HTML to contain a <div> in <div>. Error Component 
Stack

hook.js:608 Warning: An error occurred during hydration. The server HTML was 
replaced with client content in <div>. 

hydration-dev.js:31 Uncaught Error: [NFES] Page Error due to Hydration Failed, 
Please fix hydration errors above.
```

通过参考文档：[https://nextjs.org/docs/messages/react-hydration-error，以及上述关于二次渲染的分析可知：](https://nextjs.org/docs/messages/react-hydration-error%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8A%E8%BF%B0%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93%E7%9A%84%E5%88%86%E6%9E%90%E5%8F%AF%E7%9F%A5%EF%BC%9A)

本质是 **服务端渲染与客户端渲染的内容不一致。**

具体场景：

```
// 环境判断
const isTds = () => {
  const isH5 = xEnv.getPlatform() === xEnv.PLATFORM_TYPE.H5
  // 先只判断h5
  if (!isH5) return false
  if (xUa.isInServer()) return false
  let host = window?.location?.host
  if (host) {
    return host.includes('bst')
  } else {
    return false
  }
}

const isInWechatMiniProgram = () => {
  if (xUa.isInServer()) return false
  if (xEnv.getPlatform() === xEnv.PLATFORM_TYPE.CRN) return false
  try {
    let userAgent = getUserAgent().toLowerCase()
    if (userAgent.indexOf('micromessenger') > -1) {
      return (
        window.__wxjs_environment === 'miniprogram' ||
        /miniProgram/i.test(window.navigator.userAgent)
      )
    } else {
      return false
    }
  } catch (e) {
    return false
  }
}

const isInTdsMiniProgram = () => {
  if (xUa.isInServer()) return false
  return isInWechatMiniProgram() && isTds()
}
```

```
const ProductDetail = (props) => {
  console.log('isInTdsMini',isInTdsMiniProgram())
  return (
    <XView >
      <Header />
      ....
    </Xview>
  )
}
```

报错发生在ProductDetail页面上，根据文档，首先最有可能的是在组件内使用/调用了和window相关/客户端下的API，但检查了一下发现并没有；

然后一直觉得十分奇怪：对于isInTdsMiniProgram 的判断 在服务端内会被直接返回false；在客户端内isTds由于域名不是bst相关也会返回false，也就是说isInTdsMiniProgram在服务端和客户端下都会是false，怎么会出现水合不一致的情况呢？

然后就进入调试阶段，在两端内分别输出了一系列值（例如isInTdsMiniProgram、isTds、isH5等等等），经过尝试，我发现问题可能出在isTds这里，当我强制将这个值返回true的时候，水合不一致报错消失，返回false时，就会报错。

顺着这个思路，我发现isInTdsMiniProgram不一致反而不会报水合的错误，那就说明一定有别的判断也是在服务端/客户端不一致，负负得正的感觉。

最后在Header内找到了问题：

```
const Header = (props: Props) => {
  if ((xUa.isMini() || xUa.isInMini()) && !isInTdsMiniProgram()) return null
  ....
}
```

**情况1：isTds() 返回 false**

| 环境 | xUa.isInMini() | isInTdsMiniProgram() | Header条件 | 渲染结果 |
| --- | --- | --- | --- | --- |
| **服务端** | false | false | false && true → false | **正常渲染** |
| **客户端** | true | false | true && true → true | **返回 null** |

**结果**：水合不一致

**情况2：isTds() 返回 true**

| 环境 | xUa.isInMini() | isInTdsMiniProgram() | Header条件 | 渲染结果 |
| --- | --- | --- | --- | --- |
| **服务端** | false | false | false && true → false | **正常渲染** |
| **客户端** | true | true | true && false → false | **正常渲染** |

**结果**：水合一致

原因在于xUa.isInMini()这个方法在服务端内会返回false，客户端内才会返回true（ navigator方法判断ua）。

当然这只是调试阶段出现的问题，生产测试上会更改host（二编：最终改成了根据登陆态判断cookie），但通过这个例子更加深入理解了水合这一过程，也提醒我不要轻易想当然（想当然的认为isInTdsMiniProgram值就是应该一致）。